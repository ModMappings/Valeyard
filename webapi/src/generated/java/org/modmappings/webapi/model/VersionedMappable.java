/*
 * ModMappings API
 * This is the api for ModMappings. It is currently in development and in an alpha stage.
 *
 * The version of the OpenAPI document: 0.0.0-Dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.modmappings.webapi.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.modmappings.webapi.model.Visibility;

/**
 * Represents a single piece of the sourcecode whose name can be remapped in a given version of the game.
 */
@ApiModel(description = "Represents a single piece of the sourcecode whose name can be remapped in a given version of the game.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-12-22T14:33:17.064+01:00[Europe/Berlin]")
public class VersionedMappable {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public static final String SERIALIZED_NAME_CREATED_BY = "createdBy";
  @SerializedName(SERIALIZED_NAME_CREATED_BY)
  private UUID createdBy;

  public static final String SERIALIZED_NAME_CREATED_ON = "createdOn";
  @SerializedName(SERIALIZED_NAME_CREATED_ON)
  private OffsetDateTime createdOn;

  public static final String SERIALIZED_NAME_GAME_VERSION_ID = "gameVersionId";
  @SerializedName(SERIALIZED_NAME_GAME_VERSION_ID)
  private UUID gameVersionId;

  public static final String SERIALIZED_NAME_MAPPABLE_ID = "mappableId";
  @SerializedName(SERIALIZED_NAME_MAPPABLE_ID)
  private UUID mappableId;

  public static final String SERIALIZED_NAME_PARENT_CLASS_ID = "parentClassId";
  @SerializedName(SERIALIZED_NAME_PARENT_CLASS_ID)
  private UUID parentClassId;

  public static final String SERIALIZED_NAME_PARENT_METHOD_ID = "parentMethodId";
  @SerializedName(SERIALIZED_NAME_PARENT_METHOD_ID)
  private UUID parentMethodId;

  public static final String SERIALIZED_NAME_VISIBILITY = "visibility";
  @SerializedName(SERIALIZED_NAME_VISIBILITY)
  private Visibility visibility;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_DESCRIPTOR = "descriptor";
  @SerializedName(SERIALIZED_NAME_DESCRIPTOR)
  private String descriptor;

  public static final String SERIALIZED_NAME_SIGNATURE = "signature";
  @SerializedName(SERIALIZED_NAME_SIGNATURE)
  private String signature;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_LOCKED_IN = "lockedIn";
  @SerializedName(SERIALIZED_NAME_LOCKED_IN)
  private List<UUID> lockedIn = null;

  public static final String SERIALIZED_NAME_SUPER_TYPES = "superTypes";
  @SerializedName(SERIALIZED_NAME_SUPER_TYPES)
  private List<UUID> superTypes = null;

  public static final String SERIALIZED_NAME_SUB_TYPES = "subTypes";
  @SerializedName(SERIALIZED_NAME_SUB_TYPES)
  private List<UUID> subTypes = null;

  public static final String SERIALIZED_NAME_OVERRIDES = "overrides";
  @SerializedName(SERIALIZED_NAME_OVERRIDES)
  private List<UUID> overrides = null;

  public static final String SERIALIZED_NAME_OVERRIDEN_BY = "overridenBy";
  @SerializedName(SERIALIZED_NAME_OVERRIDEN_BY)
  private List<UUID> overridenBy = null;

  public static final String SERIALIZED_NAME_STATIC = "static";
  @SerializedName(SERIALIZED_NAME_STATIC)
  private Boolean _static;

  public static final String SERIALIZED_NAME_EXTERNAL = "external";
  @SerializedName(SERIALIZED_NAME_EXTERNAL)
  private Boolean external;


   /**
   * The id of the versioned mappable.
   * @return id
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the versioned mappable.")

  public UUID getId() {
    return id;
  }




   /**
   * The id of the user who created the versioned mappable.
   * @return createdBy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the user who created the versioned mappable.")

  public UUID getCreatedBy() {
    return createdBy;
  }




   /**
   * The moment the versioned mappable was created.
   * @return createdOn
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The moment the versioned mappable was created.")

  public OffsetDateTime getCreatedOn() {
    return createdOn;
  }




  public VersionedMappable gameVersionId(UUID gameVersionId) {
    
    this.gameVersionId = gameVersionId;
    return this;
  }

   /**
   * The id of the game versioned in which this versioned mappable exists.
   * @return gameVersionId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the game versioned in which this versioned mappable exists.")

  public UUID getGameVersionId() {
    return gameVersionId;
  }


  public void setGameVersionId(UUID gameVersionId) {
    this.gameVersionId = gameVersionId;
  }


  public VersionedMappable mappableId(UUID mappableId) {
    
    this.mappableId = mappableId;
    return this;
  }

   /**
   * The id of the mappable which is represented by this versioned mappable in the game version.
   * @return mappableId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the mappable which is represented by this versioned mappable in the game version.")

  public UUID getMappableId() {
    return mappableId;
  }


  public void setMappableId(UUID mappableId) {
    this.mappableId = mappableId;
  }


  public VersionedMappable parentClassId(UUID parentClassId) {
    
    this.parentClassId = parentClassId;
    return this;
  }

   /**
   * The id of the class this versioned mappable resides in. Might be null if the mappable this versioned mappable represents is not representing a method or field.
   * @return parentClassId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the class this versioned mappable resides in. Might be null if the mappable this versioned mappable represents is not representing a method or field.")

  public UUID getParentClassId() {
    return parentClassId;
  }


  public void setParentClassId(UUID parentClassId) {
    this.parentClassId = parentClassId;
  }


  public VersionedMappable parentMethodId(UUID parentMethodId) {
    
    this.parentMethodId = parentMethodId;
    return this;
  }

   /**
   * The id of the method this versioned mappable resides in. Might be null if the mappable this versioned mappable represents is not representing a parameter.
   * @return parentMethodId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the method this versioned mappable resides in. Might be null if the mappable this versioned mappable represents is not representing a parameter.")

  public UUID getParentMethodId() {
    return parentMethodId;
  }


  public void setParentMethodId(UUID parentMethodId) {
    this.parentMethodId = parentMethodId;
  }


  public VersionedMappable visibility(Visibility visibility) {
    
    this.visibility = visibility;
    return this;
  }

   /**
   * Get visibility
   * @return visibility
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Visibility getVisibility() {
    return visibility;
  }


  public void setVisibility(Visibility visibility) {
    this.visibility = visibility;
  }


  public VersionedMappable type(String type) {
    
    this.type = type;
    return this;
  }

   /**
   * Indicates the type the field. This type is in an obfuscated form and any client will need to parse the type and convert it itself into human readable language, by requesting it in the mapping type it wants to display. This field will contain an empty string if the type of mappable that this versioned mappable represents is not a field or parameter.
   * @return type
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates the type the field. This type is in an obfuscated form and any client will need to parse the type and convert it itself into human readable language, by requesting it in the mapping type it wants to display. This field will contain an empty string if the type of mappable that this versioned mappable represents is not a field or parameter.")

  public String getType() {
    return type;
  }


  public void setType(String type) {
    this.type = type;
  }


  public VersionedMappable descriptor(String descriptor) {
    
    this.descriptor = descriptor;
    return this;
  }

   /**
   * The descriptor that describes (ha) this versioned mappable. As with the type this descriptor is a raw obfuscated data entry. If the client wants to display this to a human in readable form he will need to parse this descriptor himself and request the human readable form of the mapping in the mapping type he wishes to display. This field will contain an empty string when the type of mappable that this versioned mappable represents is not a method.
   * @return descriptor
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The descriptor that describes (ha) this versioned mappable. As with the type this descriptor is a raw obfuscated data entry. If the client wants to display this to a human in readable form he will need to parse this descriptor himself and request the human readable form of the mapping in the mapping type he wishes to display. This field will contain an empty string when the type of mappable that this versioned mappable represents is not a method.")

  public String getDescriptor() {
    return descriptor;
  }


  public void setDescriptor(String descriptor) {
    this.descriptor = descriptor;
  }


  public VersionedMappable signature(String signature) {
    
    this.signature = signature;
    return this;
  }

   /**
   * The signature that describes this versioned mappable. Includes the generics of the parameter and returned type, if applicable. As with the descriptor this field contains raw obfuscated data. If the client wants to display this to a human in readable form he will need to parse this signature himself and request the human readable form of the mapping in the mapping type he wishes to display. This field will contain an empty string when the type of the mappable that this versioned mappable represents is not a method.
   * @return signature
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The signature that describes this versioned mappable. Includes the generics of the parameter and returned type, if applicable. As with the descriptor this field contains raw obfuscated data. If the client wants to display this to a human in readable form he will need to parse this signature himself and request the human readable form of the mapping in the mapping type he wishes to display. This field will contain an empty string when the type of the mappable that this versioned mappable represents is not a method.")

  public String getSignature() {
    return signature;
  }


  public void setSignature(String signature) {
    this.signature = signature;
  }


  public VersionedMappable index(Integer index) {
    
    this.index = index;
    return this;
  }

   /**
   * This indicates the parameter number for a parameter. The numbers are JVM parameter indices, for a lack of a better word, and describe both the position, as well as the width of the parameter. If the method is not static then the parameter with 0 is implicitly the keyword this, and counting starts at 1. If the method is 0 then counting starts at 0. In general all parameters are 1 wide. However doubles and longs are 2. If this versioned mappable does not represent a parameter then this is null or some random value.
   * @return index
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "This indicates the parameter number for a parameter. The numbers are JVM parameter indices, for a lack of a better word, and describe both the position, as well as the width of the parameter. If the method is not static then the parameter with 0 is implicitly the keyword this, and counting starts at 1. If the method is 0 then counting starts at 0. In general all parameters are 1 wide. However doubles and longs are 2. If this versioned mappable does not represent a parameter then this is null or some random value.")

  public Integer getIndex() {
    return index;
  }


  public void setIndex(Integer index) {
    this.index = index;
  }


  public VersionedMappable lockedIn(List<UUID> lockedIn) {
    
    this.lockedIn = lockedIn;
    return this;
  }

  public VersionedMappable addLockedInItem(UUID lockedInItem) {
    if (this.lockedIn == null) {
      this.lockedIn = new ArrayList<>();
    }
    this.lockedIn.add(lockedInItem);
    return this;
  }

   /**
   * A list of all mapping types for which no changes can be made via proposals. Only changes can be made via directly committing a mapping.
   * @return lockedIn
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of all mapping types for which no changes can be made via proposals. Only changes can be made via directly committing a mapping.")

  public List<UUID> getLockedIn() {
    return lockedIn;
  }


  public void setLockedIn(List<UUID> lockedIn) {
    this.lockedIn = lockedIn;
  }


   /**
   * A list of ids of versioned mappables that represent the super types of the versioned mappable if this represents a class. If this is not a class, then this field will be null. If this is a class and the field is empty then no super types are known.
   * @return superTypes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of ids of versioned mappables that represent the super types of the versioned mappable if this represents a class. If this is not a class, then this field will be null. If this is a class and the field is empty then no super types are known.")

  public List<UUID> getSuperTypes() {
    return superTypes;
  }




   /**
   * A list of ids of versioned mappables that represent the sub types of the versioned mappables if this represents a class. If this is not a class, then this field will be null. If this is a class and the field is empty then no sub types are known.
   * @return subTypes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of ids of versioned mappables that represent the sub types of the versioned mappables if this represents a class. If this is not a class, then this field will be null. If this is a class and the field is empty then no sub types are known.")

  public List<UUID> getSubTypes() {
    return subTypes;
  }




   /**
   * A list of ids of versioned mappables that represent the methods overriden by this method. If this versioned mappable represents a method. If this is not a method, this field will be null. If this is a method and the field is empty then no overriden methods are known.
   * @return overrides
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of ids of versioned mappables that represent the methods overriden by this method. If this versioned mappable represents a method. If this is not a method, this field will be null. If this is a method and the field is empty then no overriden methods are known.")

  public List<UUID> getOverrides() {
    return overrides;
  }




   /**
   * A list of ids of versioned mappables that represent the methods that override this method. If this versioned mappable represents a method. If this is not a method, this field will be null. If this is a method and the field is empty then no methods that override this method could be found.
   * @return overridenBy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of ids of versioned mappables that represent the methods that override this method. If this versioned mappable represents a method. If this is not a method, this field will be null. If this is a method and the field is empty then no methods that override this method could be found.")

  public List<UUID> getOverridenBy() {
    return overridenBy;
  }




  public VersionedMappable _static(Boolean _static) {
    
    this._static = _static;
    return this;
  }

   /**
   * Get _static
   * @return _static
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Boolean getStatic() {
    return _static;
  }


  public void setStatic(Boolean _static) {
    this._static = _static;
  }


  public VersionedMappable external(Boolean external) {
    
    this.external = external;
    return this;
  }

   /**
   * Get external
   * @return external
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Boolean getExternal() {
    return external;
  }


  public void setExternal(Boolean external) {
    this.external = external;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VersionedMappable versionedMappable = (VersionedMappable) o;
    return Objects.equals(this.id, versionedMappable.id) &&
        Objects.equals(this.createdBy, versionedMappable.createdBy) &&
        Objects.equals(this.createdOn, versionedMappable.createdOn) &&
        Objects.equals(this.gameVersionId, versionedMappable.gameVersionId) &&
        Objects.equals(this.mappableId, versionedMappable.mappableId) &&
        Objects.equals(this.parentClassId, versionedMappable.parentClassId) &&
        Objects.equals(this.parentMethodId, versionedMappable.parentMethodId) &&
        Objects.equals(this.visibility, versionedMappable.visibility) &&
        Objects.equals(this.type, versionedMappable.type) &&
        Objects.equals(this.descriptor, versionedMappable.descriptor) &&
        Objects.equals(this.signature, versionedMappable.signature) &&
        Objects.equals(this.index, versionedMappable.index) &&
        Objects.equals(this.lockedIn, versionedMappable.lockedIn) &&
        Objects.equals(this.superTypes, versionedMappable.superTypes) &&
        Objects.equals(this.subTypes, versionedMappable.subTypes) &&
        Objects.equals(this.overrides, versionedMappable.overrides) &&
        Objects.equals(this.overridenBy, versionedMappable.overridenBy) &&
        Objects.equals(this._static, versionedMappable._static) &&
        Objects.equals(this.external, versionedMappable.external);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, createdBy, createdOn, gameVersionId, mappableId, parentClassId, parentMethodId, visibility, type, descriptor, signature, index, lockedIn, superTypes, subTypes, overrides, overridenBy, _static, external);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VersionedMappable {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    createdOn: ").append(toIndentedString(createdOn)).append("\n");
    sb.append("    gameVersionId: ").append(toIndentedString(gameVersionId)).append("\n");
    sb.append("    mappableId: ").append(toIndentedString(mappableId)).append("\n");
    sb.append("    parentClassId: ").append(toIndentedString(parentClassId)).append("\n");
    sb.append("    parentMethodId: ").append(toIndentedString(parentMethodId)).append("\n");
    sb.append("    visibility: ").append(toIndentedString(visibility)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    descriptor: ").append(toIndentedString(descriptor)).append("\n");
    sb.append("    signature: ").append(toIndentedString(signature)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    lockedIn: ").append(toIndentedString(lockedIn)).append("\n");
    sb.append("    superTypes: ").append(toIndentedString(superTypes)).append("\n");
    sb.append("    subTypes: ").append(toIndentedString(subTypes)).append("\n");
    sb.append("    overrides: ").append(toIndentedString(overrides)).append("\n");
    sb.append("    overridenBy: ").append(toIndentedString(overridenBy)).append("\n");
    sb.append("    _static: ").append(toIndentedString(_static)).append("\n");
    sb.append("    external: ").append(toIndentedString(external)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

