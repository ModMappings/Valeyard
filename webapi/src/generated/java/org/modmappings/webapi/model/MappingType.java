/*
 * ModMappings API
 * This is the api for ModMappings. It is currently in development and in an alpha stage.
 *
 * The version of the OpenAPI document: 0.0.0-Dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.modmappings.webapi.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.UUID;

/**
 * MappingType
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-12-22T14:33:17.064+01:00[Europe/Berlin]")
public class MappingType {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public static final String SERIALIZED_NAME_CREATED_BY = "createdBy";
  @SerializedName(SERIALIZED_NAME_CREATED_BY)
  private UUID createdBy;

  public static final String SERIALIZED_NAME_CREATED_ON = "createdOn";
  @SerializedName(SERIALIZED_NAME_CREATED_ON)
  private OffsetDateTime createdOn;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_EDITABLE = "editable";
  @SerializedName(SERIALIZED_NAME_EDITABLE)
  private Boolean editable;

  public static final String SERIALIZED_NAME_STATE_IN = "stateIn";
  @SerializedName(SERIALIZED_NAME_STATE_IN)
  private String stateIn;

  public static final String SERIALIZED_NAME_STATE_OUT = "stateOut";
  @SerializedName(SERIALIZED_NAME_STATE_OUT)
  private String stateOut;


   /**
   * The id of the mapping type.
   * @return id
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the mapping type.")

  public UUID getId() {
    return id;
  }




   /**
   * The id of the user who created the mapping type.
   * @return createdBy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The id of the user who created the mapping type.")

  public UUID getCreatedBy() {
    return createdBy;
  }




   /**
   * The moment the mapping type was created.
   * @return createdOn
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The moment the mapping type was created.")

  public OffsetDateTime getCreatedOn() {
    return createdOn;
  }




  public MappingType name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name of the mapping type. Has to be unique.
   * @return name
  **/
  @ApiModelProperty(required = true, value = "The name of the mapping type. Has to be unique.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public MappingType editable(Boolean editable) {
    
    this.editable = editable;
    return this;
  }

   /**
   * Indicates if this mapping type is editable or not. For none editable mapping types the api prevents users from making and proposing new mappings. Making this mapping type basically only available for lookup purposes!
   * @return editable
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates if this mapping type is editable or not. For none editable mapping types the api prevents users from making and proposing new mappings. Making this mapping type basically only available for lookup purposes!")

  public Boolean getEditable() {
    return editable;
  }


  public void setEditable(Boolean editable) {
    this.editable = editable;
  }


  public MappingType stateIn(String stateIn) {
    
    this.stateIn = stateIn;
    return this;
  }

   /**
   * The state of the source code that this mapping type maps away from.
   * @return stateIn
  **/
  @ApiModelProperty(required = true, value = "The state of the source code that this mapping type maps away from.")

  public String getStateIn() {
    return stateIn;
  }


  public void setStateIn(String stateIn) {
    this.stateIn = stateIn;
  }


  public MappingType stateOut(String stateOut) {
    
    this.stateOut = stateOut;
    return this;
  }

   /**
   * The state of the source code that this mapping type maps into.
   * @return stateOut
  **/
  @ApiModelProperty(required = true, value = "The state of the source code that this mapping type maps into.")

  public String getStateOut() {
    return stateOut;
  }


  public void setStateOut(String stateOut) {
    this.stateOut = stateOut;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MappingType mappingType = (MappingType) o;
    return Objects.equals(this.id, mappingType.id) &&
        Objects.equals(this.createdBy, mappingType.createdBy) &&
        Objects.equals(this.createdOn, mappingType.createdOn) &&
        Objects.equals(this.name, mappingType.name) &&
        Objects.equals(this.editable, mappingType.editable) &&
        Objects.equals(this.stateIn, mappingType.stateIn) &&
        Objects.equals(this.stateOut, mappingType.stateOut);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, createdBy, createdOn, name, editable, stateIn, stateOut);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MappingType {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    createdOn: ").append(toIndentedString(createdOn)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    editable: ").append(toIndentedString(editable)).append("\n");
    sb.append("    stateIn: ").append(toIndentedString(stateIn)).append("\n");
    sb.append("    stateOut: ").append(toIndentedString(stateOut)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

